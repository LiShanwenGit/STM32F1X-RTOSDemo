/**************************************************************************
* 文件名：DAC.c                                                           *
* 编写人：离逝的风                                                        *
* 更新时间：2018.12.11                                                    *
* 说明：此文件属于开源，所有权对任何人开放					                     	*
* 如有问题请联系邮箱：1477153217@qq.com                                   *
* 使用步骤：                                                              *
* 1.开启DACx_EN设置为1                                                    *
* 2.设置通道触发方式，即设置DAC1_TR                                       *
* 3.设置DAC数据长度                                                       *
* 4.设置TIM触发时间                                                       *
* 5.在主函数中初始化DAC，即调用DACx_Init                                  *
***************************************************************************/

#include "DAC.h"

/*######################################下面为DAC数字量数据来源#######################################*/
unsigned int DAC1_DATE[DAC1_Lenth]={
2048 ,2252 ,2455 ,2653 ,2846 ,3030 ,3204 ,3367 ,3517 ,3652 ,3771 ,3873 ,3957 ,4021 ,4066 ,4091 ,4095 ,4079 ,4042 ,
3986 ,3910 ,3816 ,3704 ,3575 ,3431 ,3274 ,3104 ,2923 ,2734 ,2538 ,2337 ,2133 ,1928 ,1725 ,1525 ,1330 ,1142 ,963 ,
795 ,639 ,498 ,372 ,263 ,172 ,99 ,46 ,13 ,0 ,8 ,36 ,84 ,152 ,239 ,344 ,465 ,603 ,755 ,920 ,1096 ,1282 ,1476 ,1675 ,
1878 
};
unsigned int DAC2_DATE[DAC2_Lenth]={0};

/*######################################下面为DAC1初始化函数###########################################*/
/************************************************************
函数：DAC1_Init
参数：无
返回值：无
说明：初始化DAC1
*************************************************************/
#if(DAC1_EN==1)
void DAC1_Init(void)
{
	/***********下面为引脚初始化***************/
	RCC->APB2ENR|=(1<<2);    //开启GPIOA时钟
	RCC->APB2ENR|=(1<<0);    //开启复用引脚时钟
	GPIOA->CRL&=0XFFF0FFFF;  //PA4
	GPIOA->CRL|=0X00000000;  //设置为模拟输入
	
	/***********下面为DMA配置******************/
	//说明：DAC1在DMA2通道3   DAC2在DAM2通道4
	RCC->AHBENR|=1<<1;              //开启DMA2时钟
	DMA2_Channel3->CCR|=(0<<14);    //非存储器到存储器 
	DMA2_Channel3->CCR|=(2<<12);    //通道优先级设置为高
	DMA2_Channel3->CCR|=(2<<10);    //存储器数据宽度设置为32位，因为单片机地址为32位
	DMA2_Channel3->CCR|=(2<<8);     //外设数据宽度设置为32
	DMA2_Channel3->CCR|=(1<<7);     //存储器地址增加
	DMA2_Channel3->CCR|=(0<<6);     //外设地址不增加
	DMA2_Channel3->CCR|=(1<<5);     //循环模式
  DMA2_Channel3->CCR|=(1<<4);     //从存储器读，即从存储器到外设
	
  DMA2_Channel3->CNDTR&=0X00;     
	DMA2_Channel3->CNDTR|=DAC1_Lenth;//外设地址不增加
	DMA2_Channel3->CPAR|=(unsigned long)(&DAC->DHR12R1);
	DMA2_Channel3->CMAR|=(unsigned long)(DAC1_DATE);
	DMA2_Channel3->CCR|=(1<<0);     //开启DMA2通道3
	
	/***********下面为定时器配置***************/
	#if(DAC1_TR==0)                 //如果选择TIM6
	  RCC->APB1ENR|=(1<<4);         //开启TIM6时钟
		TIM6->CR1|=(1<<7);            //计数器自动重装
		TIM6->CR1|=(0<<3);            //更新事件计数器不停止
		TIM6->CR1|=(1<<2);            //只有计数器溢出才产生更新事件
		TIM6->CR2|=(2<<4);            //更新事件被用作触发信号
    TIM6->DIER|=(1<<8);           //使能更新DMA请求
		TIM6->PSC&=0X00;TIM6->ARR&=0X00;  //清楚分频值和预装值
		TIM6->PSC|=DAC1_TIM_PSC;      //定时器分频系数
		TIM6->ARR|=DAC1_TIM_ARR;      //定时器预装值	           
		TIM6->CR1|=(1<<0);            //开始计数
	#endif
	
	#if(DAC1_TR==1)                 //如果选择TIM7
	  RCC->APB1ENR|=(1<<5);         //开启TIM7时钟
		TIM7->CR1|=(1<<7);            //计数器自动重装
		TIM7->CR1|=(0<<3);            //更新事件计数器不停止
		TIM7->CR1|=(1<<2);            //只有计数器溢出才产生更新事件
		TIM7->CR2|=(2<<4);            //更新事件被用作触发信号
    TIM7->DIER|=(1<<8);           //使能更新DMA请求
		TIM7->PSC&=0X00;TIM7->ARR&=0X00;  //清楚分频值和预装值
		TIM7->PSC|=DAC1_TIM_PSC;      //定时器分频系数
		TIM7->ARR|=DAC1_TIM_ARR;      //定时器预装值	
		TIM7->CR1|=(1<<0);            //开始计数
	#endif
	
	/*********下面为DAC设置********************/
	RCC->APB1ENR|=(1<<29);          //开启DAC时钟
	DAC->CR|=(1<<12);               //使能DAC1的DAM
	DAC->CR|=(0<<6);                //关闭波形发生器
	#if(DAC1_TR==0)                 //如果选择TIM6
	   DAC->CR|=(0<<3);             //选择TIM6触发
	#endif	
  #if(DAC1_TR==1)                 //如果选择TIM7 	
	   DAC->CR|=(2<<3);             //选择TIM7触发
	#endif	
	DAC->CR|=(1<<2);                //使能DAC通道1触发
	DAC->CR|=(1<<1);                //关闭DAC通道1缓存
	DAC->CR|=(1<<0);                //开启DAC1
}
#endif

/*######################################下面为DAC2初始化函数###########################################*/
/************************************************************
函数：DAC2_Init
参数：无
返回值：无
说明：初始化DAC2
*************************************************************/
#if(DAC2_EN==1)
void DAC2_Init(void)
{
	/***********下面为引脚初始化***************/
	RCC->APB2ENR|=(1<<2);    //开启GPIOA时钟
	RCC->APB2ENR|=(1<<0);    //开启复用引脚时钟
	GPIOA->CRL&=0XFF0FFFFF;  //PA5
	GPIOA->CRL|=0X00000000;  //设置为模拟输入
	
	/***********下面为DMA配置******************/
	//说明：DAC1在DMA2通道3   DAC2在DAM2通道4
	RCC->AHBENR|=1<<1;              //开启DMA2时钟
	DMA2_Channel4->CCR|=(0<<14);    //非存储器到存储器 
	DMA2_Channel4->CCR|=(2<<12);    //通道优先级设置为高
	DMA2_Channel4->CCR|=(2<<10);    //存储器数据宽度设置为32位，因为单片机地址为32位
	DMA2_Channel4->CCR|=(2<<8);     //外设数据宽度设置为32
	DMA2_Channel4->CCR|=(1<<7);     //存储器地址增加
	DMA2_Channel4->CCR|=(0<<6);     //外设地址不增加
	DMA2_Channel4->CCR|=(1<<5);     //循环模式
  DMA2_Channel4->CCR|=(1<<4);     //从存储器读，即从存储器到外设
	
  DMA2_Channel4->CNDTR&=0X00;     
	DMA2_Channel4->CNDTR|=DAC2_Lenth;//外设地址不增加
	DMA2_Channel4->CPAR|=(unsigned long)(&DAC->DHR12R2);
	DMA2_Channel4->CMAR|=(unsigned long)(DAC2_DATE);
	DMA2_Channel4->CCR|=(1<<0);     //开启DMA2通道4
	
	/***********下面为定时器配置***************/
	#if(DAC2_TR==0)                 //如果选择TIM6
	  RCC->APB1ENR|=(1<<4);         //开启TIM6时钟
		TIM6->CCR1|=(1<<7);           //计数器自动重装
		TIM6->CCR1|=(0<<3);           //更新事件计数器不停止
		TIM6->CCR1|=(1<<2);           //只有计数器溢出才产生更新事件
		TIM6->CR2|=(2<<4);            //更新事件被用作触发信号
    TIM6->DIER|=(1<<8);           //使能更新DMA请求
		TIM6->PSC&=0X00;TIM6->ARR&=0X00;  //清楚分频值和预装值
		TIM6->PSC|=DAC2_TIM_PSC;      //定时器分频系数
		TIM6->ARR|=DAC2_TIM_ARR;      //定时器预装值	
		TIM6->CR1|=(1<<0);            //开始计数
	#endif
	
	#if(DAC2_TR==1)                 //如果选择TIM7
	  RCC->APB1ENR|=(1<<5);         //开启TIM7时钟
		TIM7->CCR1|=(1<<7);           //计数器自动重装
		TIM7->CCR1|=(0<<3);           //更新事件计数器不停止
		TIM7->CCR1|=(1<<2);           //只有计数器溢出才产生更新事件
		TIM7->CR2|=(2<<4);            //更新事件被用作触发信号
    TIM7->DIER|=(1<<8);           //使能更新DMA请求
		TIM7->PSC&=0X00;TIM6->ARR&=0X00;  //清楚分频值和预装值
		TIM7->PSC|=DAC2_TIM_PSC;      //定时器分频系数
		TIM7->ARR|=DAC2_TIM_ARR;      //定时器预装值	
		TIM7->CR1|=(1<<0);            //开始计数
	#endif
	
	/*********下面为DAC设置********************/
  RCC->APB1ENR|=(1<<29);          //开启DAC时钟
	DAC->CR|=(1<<28);               //使能DAC2的DAM
	DAC->CR|=(0<<22);               //关闭波形发生器
	#if(DAC2_TR==0)                 //如果选择TIM6
	   DAC->CR|=(0<<19);            //选择TIM6触发
	#endif	
  #if(DAC2_TR==1)                 //如果选择TIM7 	
	   DAC->CR|=(2<<19);            //选择TIM7触发
	#endif	
	DAC->CR|=(1<<18);               //使能DAC通道2触发
	DAC->CR|=(1<<17);               //关闭DAC通道2缓存
	DAC->CR|=(1<<16);               //开启DAC2
}

#endif

//FILE END

